<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F28%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象和面向过程 面向对象和面向过程是两种不同的编程 [ ] 面向过程：指的是开发过程中专注于每个功能的具体实现方式 [ ] 面向对象：指的是开发过程中，分析大体步骤，找到每个步骤可以辅助我们开发的对象（工具）进行操作 以前做过的面向对象操作：使用js内置对象功能完成效果、使用jQuery进行开发 创建方式： 1 对象字面量{} 2 构造函数创建方式new Object（） 3 自定义构造函数（通过工厂模式的改进得到的产物） ​ 3.1 目的：需要根据自身设置某一类特定的对象形式。 ​ 3.2 使用方式： 123- 构造函数命名首字母大写（建议规范）- 构造函数内通过this设置功能- 调用时加new 4 new的作用： 123- 调用构造函数- 将构造函数内的this修改为实例对象- 将this返回 123456789 function createObj(name, age, sex) &#123; this.n = name; this.a = age; this.s = sex; this.sayHi = function () &#123; console.log(this.n + this.a + this.s); &#125;;&#125;var n1 = new createObj('jack', 12, '男'); 面向对象的三个特征： 封装：根据功能性，将多个用于相同操作的功能封装到一个对象中。例如内置的Math 继承：让功能可以更好的复用。 多态：让功能使用的灵活性增强 。 原型（prototype） 函数自带属性，默认值是一个对象 作用：用于保存构造函数中的公用方法值 使用方式：将构造函数中的方法设置给 prototype即可。所有通过当前构造函数创建的对象都可以使用prototype中的方法 prototype使用的原理 观察了实例对象，发现内部不具有方法，但是又可以调用 我们发现实例对象中都具有一个proto属性，这个属性不是我们自己加的 这个属性是new进行实例对象创建时，给对象添加的属性 小结：重新说明对象属性的访问过程 对象访问属性时，首先查找自身，如果存在则使用；如果不存在，则查找构造函数的prototype，如果有，就使用。 constructor 原型中自带属性constructor，这是属性值为构造函数（构造器） constructor属性是用来给实例对象访问使用的 作用：用来确定实例对象和构造函数之间的关系（明确实例对象可以使用的功能） 原型设置的第二种方式123456789101112131415161718function CreateObj () &#123; this.name = 'jack';&#125;CreateObj.prototype = &#123; sayHi : function () &#123; console.log('这是sayHi方法'); &#125;, sayHehe : function () &#123; console.log('这是sayHehe方法'); &#125;, // 注意：如果通过对象赋值的方式设置prototype // 需要自己补上constructor属性 constructor : CreateObj&#125;;var c1 = new CreateObj();c1.sayHi();c1.sayHehe();console.log(c1); 如果通过对象赋值的方式设置prototype，需要自己补上constructor属性 给内置对象设置自定义功能 [x] 如果我们要给内置对象设置自定义的功能，需要设置在原型中 1234567891011121314Array.prototype.getSum = function () &#123; // 1 遍历当前调用方法的数组 var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; // 2 求和 sum += this[i]; &#125; // 3 返回结果 return sum;&#125;;var arr = [1, 2, 3, 4, 5];console.log(arr);console.log(arr.getSum()); //15 三者关系实例对象：实例对象都具有proto,就是原型对象 原型对象：原型对象都具有constructor属性，就是构造函数 构造函数：构造函数都具有prototype属性，就是原型对象 函数的call方法call方法的使用 call方法用于修改函数内的this，同时调用函数 参数1：设置某个对象，可以将这个对象设置为函数内的this 后续参数表示给函数传递的实参 12345function fun (n, m) &#123; // console.log('这是fun的代码'); console.log(this, n, m);&#125;fun.call(&#123;name : 'jack'&#125;, 100, 200); 继承 继承的目的是为了更好的功能复用 ​ 我们可以通过某些方式让构造函数A中的功能 让构造函数B得到并使用。 构造函数继承 继承的是属性 123456789101112131415161718192021222324252627282930313233 function People (name, age) &#123; this.name = name; this.age = age;&#125;People.prototype.sayHi = function () &#123; console.log('你好，我叫' + this.name);&#125;;/* var p1 = new People('jack', 18);*/function Student (name, age, banJi) &#123; /* this.name = name; this.age = age; */ // 通过观察我们发现，Student中的部分功能在People中是存在的，可以通过继承方式得到 // 在Student构造函数中的this是s1,将这个this传递给call方法 // 作用为：调用People并将People中的this设置为s1，s1就具有了People中的所有功能 // 小结：这种继承方式只能继承构造函数体中的属性 People.call(this, name, age); this.banJi = banJi;&#125;/* Student.prototype.sayHi = function () &#123; console.log('你好，我叫' + this.name);&#125;; */Student.prototype.study = function () &#123; console.log('每天代码1w行');&#125;;var s1 = new Student('rose', 21, '2年级1班');/* console.log(s1.name, s1.age, s1.banJi);s1.sayHi();s1.study(); */console.log(s1);s1.sayHi(); 原型继承 原型继承的是方法（功能） 由于通过赋值方式设置prototype，constructor属性就不存在了，需要进行设置，谁调用就设置constructor给谁 如果要设置新的功能，需要书写在原型继承操作之后 原型继承操作时，被继承的构造函数体中的数据是可以设置成功的，但是永远是固定值。所以不好用，我们还是需要自己设置 小结：不需要给继承操作时的构造函数传参，因为根本不用 1234567891011121314151617181920212223242526272829303132333435363738function People (name, age) &#123; this.name = name; this.age = age;&#125;People.prototype.sayHi = function () &#123; console.log('你好，我叫' + this.name);&#125;;People.prototype.sayHehe = function () &#123; console.log('你好，我叫' + this.name);&#125;;function Student (name, age, banJi) &#123; this.name = name; this.age = age; this.banJi = banJi;&#125;// 我们希望可以得到People原型中的方法// - People的所有功能都可以被People的实例对象使用// - 我们将People的实例对象设置给Student.prototype// - 注意点：/// 1 由于通过赋值方式设置prototype，constructor属性就不存在了，需要进行设置// 2 如果要设置新的功能，需要书写在原型继承操作之后// 3 原型继承操作时，被继承的构造函数体中的数据是可以设置成功的，但是永远是固定值// - 所以不好用，我们还是需要自己设置// - 小结：不需要给继承操作时的构造函数传参，因为根本不用Student.prototype = new People();Student.prototype.study = function () &#123; console.log('每天代码1w行');&#125;;Student.prototype.constructor = Student;var s1 = new Student('jack', 18, '三年级一班');s1.sayHi();s1.sayHehe();s1.study();console.log(s1.constructor);console.log(s1.name, s1.age);console.log(s1); 组合继承通过前面两种继承方式我们发现 借用构造函数继承可以继承构造函数体中的属性 原型继承可以继承原型中的方法 将两种继承方式一起使用就可以完整的继承了，称为组合继承]]></content>
  </entry>
  <entry>
    <title><![CDATA[var和let/const的区别]]></title>
    <url>%2F2019%2F03%2F28%2Fvar%E5%92%8Clet%E3%80%81const%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[let和const是 ES6 新增的命令，用于声明变量，这两个命令跟 ES5 的var有许多不同，并且let和const也有一些细微的不同。 内容：var和let/const的区别 块级作用域 不存在变量提升 暂时性死区 不可重复声明 let、const声明的全局变量不会挂在顶层对象下面 const命令两个注意点: const 声明之后必须马上赋值，否则会报错 const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。 为什么需要块级作用域?ES5只有全局作用域和函数作用域，没有块级作用域。 这带来很多不合理的场景: 内层变量可能覆盖外层变量 用来计数的循环变量泄露为全局变量 1234567891011121314var tmp = new Date();function f() &#123; console.log(tmp); // 想打印外层的时间作用域 if (false) &#123; var tmp = 'hello world'; // 这里声明的作用域为整个函数 &#125;&#125;f(); // undefinedvar s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]); // i应该为此次for循环使用的变量&#125;console.log(i); // 5 全局范围都可以读到 块级作用域 作用域 12345678function fn() &#123; let n = 5; if (true) &#123; let n = 10; console.log(n); // 10 内层的n &#125; console.log(n); // 5 当前层的n&#125; 块级作用域任意嵌套 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错 读不到子作用域的变量&#125;&#125;&#125;&#125;; 块级作用域真正使代码分割成块了 12345678&#123;let a = ...;...&#125;&#123;let a = ...;...&#125; 以上形式，可以用于测试一些想法，不用担心变量重名，也不用担心外界干扰 块级作用域声明函数： 在块级作用域声明函数，因为浏览器要兼容老代码，会产生一些问题！ 在块级作用域声明函数，最好使用匿名函数的形式。 123if(true)&#123; let a = function () &#123;&#125;; // 作用域为块级 令声明的函数作用域范围更清晰&#125; ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 报错'use strict';if (true) function f() &#123;&#125; // 我们需要给if加个&#123;&#125; // 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125; 不存在变量提升变量提升的现象：在同一作用域下，变量可以在声明之前使用，值为 undefined ES5 时使用var声明变量，经常会出现变量提升的现象。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 12345var tmp = 123; // 声明if (true) &#123; tmp = 'abc'; // 报错 因为本区域有tmp声明变量 let tmp; // 绑定if这个块级的作用域 不能出现tmp变量&#125; 暂时性死区和不能变量提升的意义在于: 为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 不允许重复声明变量 在测试时出现这种情况:var a= &#39;声明&#39;;const a = &#39;不报错&#39;，这种情况是因为babel在转化的时候，做了一些处理，在浏览器的控制台中测试，就成功报错 let、const不允许在相同作用域内，重复声明同一个变量 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; let、const声明的全局变量不会挂在顶层对象下面 浏览器环境顶层对象是: window node环境顶层对象是: global var声明的全局变量会挂在顶层对象下面，而let、const不会挂在顶层对象下面。如下面这个栗子 1234567var a = 1;// 如果在 Node环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined const命令 一旦声明，必须马上赋值 123let p; var p1; // 不报错const p3 = '马上赋值'const p3; // 报错 没有赋值 const一旦声明值就不能改变 简单类型:不能改动12const p = '不能改变';p = '报错' 复杂类型:变量指针不能变考虑如下情况： 12345678910const p = ['不能改动'];const p2 = &#123; name: 'jack'&#125;;p[0] = '不报错';p2.name = '不报错';p = ['报错'];p2 = &#123; name: '报错'&#125;; const所说的一旦声明值就不能改变，实际上指的是：变量指向的那个内存地址所保存的数据不得改动 简单类型(number、string、boolean)：内存地址就是值,即常量(一变就报错). 复杂类型(对象、数组等)：地址保存的是一个指针，const只能保证指针是固定的(总是指向同一个地址),它内部的值是可以改变的(不要以为const就安全了！) 所以只要不重新赋值整个数组/对象， 因为保存的是一个指针，所以对数组使用的push、shift、splice等方法也是允许的，你就是把值一个一个全都删光了都不会报错。 复杂类型还有函数，正则等，这点也要注意一下。 总结:再总结一下，看到这些名词，脑子里应该会有对应的理解，如果没有的话，那可以再看看对应的内容。 var和let/const的区别: 块级作用域 不存在变量提升 暂时性死区 不可重复声明 let、const声明的全局变量不会挂在顶层对象下面 const命令两个注意点: let可以先声明稍后再赋值,而const在 声明之后必须马上赋值，否则会报错 const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。 let、const使用场景: let使用场景：变量，用以替代var。 const使用场景：常量、声明匿名函数、箭头函数的时候。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局常用盒子居中方法]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以下样式中的html均为下图所示 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 负margin居中 1234567891011121314151617.father &#123; position: relative; width: 200px; height: 150px; background-color: #ddd; margin: 100px auto; &#125; .son &#123; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -25px; width: 50px; height: 50px; background-color: #f00; &#125; 绝对定位居中 123456789101112131415161718.farter &#123; position: relative; width: 200px; height: 200px; background-color: #cccccc; margin: 50px auto;&#125;.son &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; width: 100px; height: 100px; background-color: #00ff00;&#125; transform居中 12345678910111213141516.father &#123; position: relative; width: 200px; height: 200px; background-color: #ddd; margin: 50px auto;&#125; .son &#123; position: absolute; width: 50px; height: 50px; background-color: #0f0; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex居中 1234567891011121314.farter &#123; display: flex; justify-content: center; align-items: center; width: 200px; height: 200px; background-color: #ddd; margin: 50px auto;&#125;.son &#123; width: 100px; height: 100px; background-color: #00ff00;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
