<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[var和let/const的区别]]></title>
    <url>%2F2019%2F03%2F28%2Fvar%E5%92%8Clet%E3%80%81const%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[let和const是 ES6 新增的命令，用于声明变量，这两个命令跟 ES5 的var有许多不同，并且let和const也有一些细微的不同。 内容：var和let/const的区别 块级作用域 不存在变量提升 暂时性死区 不可重复声明 let、const声明的全局变量不会挂在顶层对象下面 const命令两个注意点: const 声明之后必须马上赋值，否则会报错 const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。 为什么需要块级作用域?ES5只有全局作用域和函数作用域，没有块级作用域。 这带来很多不合理的场景: 内层变量可能覆盖外层变量 用来计数的循环变量泄露为全局变量 1234567891011121314var tmp = new Date();function f() &#123; console.log(tmp); // 想打印外层的时间作用域 if (false) &#123; var tmp = 'hello world'; // 这里声明的作用域为整个函数 &#125;&#125;f(); // undefinedvar s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]); // i应该为此次for循环使用的变量&#125;console.log(i); // 5 全局范围都可以读到 块级作用域 作用域 12345678function fn() &#123; let n = 5; if (true) &#123; let n = 10; console.log(n); // 10 内层的n &#125; console.log(n); // 5 当前层的n&#125; 块级作用域任意嵌套 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错 读不到子作用域的变量&#125;&#125;&#125;&#125;; 块级作用域真正使代码分割成块了 12345678&#123;let a = ...;...&#125;&#123;let a = ...;...&#125; 以上形式，可以用于测试一些想法，不用担心变量重名，也不用担心外界干扰 块级作用域声明函数： 在块级作用域声明函数，因为浏览器要兼容老代码，会产生一些问题！ 在块级作用域声明函数，最好使用匿名函数的形式。 123if(true)&#123; let a = function () &#123;&#125;; // 作用域为块级 令声明的函数作用域范围更清晰&#125; ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 报错'use strict';if (true) function f() &#123;&#125; // 我们需要给if加个&#123;&#125; // 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125; 不存在变量提升变量提升的现象：在同一作用域下，变量可以在声明之前使用，值为 undefined ES5 时使用var声明变量，经常会出现变量提升的现象。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 12345var tmp = 123; // 声明if (true) &#123; tmp = 'abc'; // 报错 因为本区域有tmp声明变量 let tmp; // 绑定if这个块级的作用域 不能出现tmp变量&#125; 暂时性死区和不能变量提升的意义在于: 为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 不允许重复声明变量 在测试时出现这种情况:var a= &#39;声明&#39;;const a = &#39;不报错&#39;，这种情况是因为babel在转化的时候，做了一些处理，在浏览器的控制台中测试，就成功报错 let、const不允许在相同作用域内，重复声明同一个变量 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; let、const声明的全局变量不会挂在顶层对象下面 浏览器环境顶层对象是: window node环境顶层对象是: global var声明的全局变量会挂在顶层对象下面，而let、const不会挂在顶层对象下面。如下面这个栗子 1234567var a = 1;// 如果在 Node环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined const命令 一旦声明，必须马上赋值 123let p; var p1; // 不报错const p3 = '马上赋值'const p3; // 报错 没有赋值 const一旦声明值就不能改变 简单类型:不能改动12const p = '不能改变';p = '报错' 复杂类型:变量指针不能变考虑如下情况： 12345678910const p = ['不能改动'];const p2 = &#123; name: 'jack'&#125;;p[0] = '不报错';p2.name = '不报错';p = ['报错'];p2 = &#123; name: '报错'&#125;; const所说的一旦声明值就不能改变，实际上指的是：变量指向的那个内存地址所保存的数据不得改动 简单类型(number、string、boolean)：内存地址就是值,即常量(一变就报错). 复杂类型(对象、数组等)：地址保存的是一个指针，const只能保证指针是固定的(总是指向同一个地址),它内部的值是可以改变的(不要以为const就安全了！) 所以只要不重新赋值整个数组/对象， 因为保存的是一个指针，所以对数组使用的push、shift、splice等方法也是允许的，你就是把值一个一个全都删光了都不会报错。 复杂类型还有函数，正则等，这点也要注意一下。 总结:再总结一下，看到这些名词，脑子里应该会有对应的理解，如果没有的话，那可以再看看对应的内容。 var和let/const的区别: 块级作用域 不存在变量提升 暂时性死区 不可重复声明 let、const声明的全局变量不会挂在顶层对象下面 const命令两个注意点: let可以先声明稍后再赋值,而const在 声明之后必须马上赋值，否则会报错 const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。 let、const使用场景: let使用场景：变量，用以替代var。 const使用场景：常量、声明匿名函数、箭头函数的时候。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局常用盒子居中方法]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以下样式中的html均为下图所示 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 负margin居中 1234567891011121314151617.father &#123; position: relative; width: 200px; height: 150px; background-color: #ddd; margin: 100px auto; &#125; .son &#123; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -25px; width: 50px; height: 50px; background-color: #f00; &#125; 绝对定位居中 123456789101112131415161718.farter &#123; position: relative; width: 200px; height: 200px; background-color: #cccccc; margin: 50px auto;&#125;.son &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; width: 100px; height: 100px; background-color: #00ff00;&#125; transform居中 12345678910111213141516.father &#123; position: relative; width: 200px; height: 200px; background-color: #ddd; margin: 50px auto;&#125; .son &#123; position: absolute; width: 50px; height: 50px; background-color: #0f0; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex居中 1234567891011121314.farter &#123; display: flex; justify-content: center; align-items: center; width: 200px; height: 200px; background-color: #ddd; margin: 50px auto;&#125;.son &#123; width: 100px; height: 100px; background-color: #00ff00;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
